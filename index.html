<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Para la Secre mas hermosa</title>
    <link rel="icon" type="image/png" sizes="16x16" href="https://i.pinimg.com/originals/2b/3b/74/2b3b7425df150cd5cddd1f1f908284b1.jpg" style="border-radius: 30px;">

    <!-- CSS de Bootstrap -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <!-- Estilos principales -->
    <style>
      /***********************************************
       * TU CSS EXISTENTE
       ***********************************************/
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        overflow: hidden;
        background: #16000a;
      }
      body {
        -webkit-font-smoothing: antialiased;
        color: #ffdada;
      }

      .webgl {
        position: fixed;
        width: 100vw;
        height: 100vh;
        top: 0;
        left: 0;
        outline: none;
      }

      body::before {
        content: "";
        position: absolute;
        border: 8px solid;
        inset: 1rem;
        z-index: 100;
        pointer-events: none;
      }

      h1 {
        position: absolute;
        top: 10vh;
        left: 2.5rem;
        right: 1rem;
        text-align: center;
        font-family: ador-hairline, sans-serif;
        font-weight: 900;
        font-size: max(1rem, 3vh);
      }

      .boton1 {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        height: 12vh;
        width: 12vh;
        transform: translateY(2vh);
        right: 0;
        margin: auto;
        -webkit-appearance: none;
        background: transparent;
        color: inherit;
        border: none;
        cursor: pointer;
      }

      svg {
        width: 3.5vh;
      }

      /***********************************************
       * ESTILOS √öNICOS PARA EL MODAL IZQUIERDO
       ***********************************************/
      /* Aseguramos que el modal tenga un z-index mayor que todo lo anterior */
      #uniqueLeftModal {
        z-index: 999999; /* Un valor muy alto para que se superponga */
      }

      /* Di√°logo del modal, pegado a la izquierda con animaci√≥n */
/* El comportamiento "slideleft" se mantiene en pantallas grandes. */
.modal-dialog-slideleft {
      position: fixed;        /* Fijo para animar desde la izquierda */
      left: 0;
      top: 0;
      bottom: 0;
      max-width: 40%;         /* Ancho en pantallas grandes */
      height: 100%;
      margin: 0;
      transform: translateX(-100%);
      transition: transform 0.4s ease-in-out;
      color: #000;            /* Texto negro interno */
    }

    /* Cuando el modal est√° abierto, se desliza */
    .modal.show .modal-dialog-slideleft {
      transform: translateX(0);
    }

    /* 
    Para que el contenido pueda desplazarse 
    si es muy largo en pantallas grandes 
    */
    .modal-content {
      max-height: 100%;
      overflow-y: auto;
    }

    /*
    =======================================
    RESPONSIVIDAD
    =======================================
    */

    /* A partir de 992px hacia abajo (tablet o menor) 
       quitamos la posici√≥n fija y dejamos el modal 
       con el comportamiento "normal" de Bootstrap. */
    @media (max-width: 992px) {
      .modal-dialog-slideleft {
        position: static !important;
        max-width: 100% !important;
        height: auto !important;
        transform: none !important;
        margin: 1rem auto; /* Espacio alrededor */
      }

      .modal.show .modal-dialog-slideleft {
        transform: none;
      }

      /* 
      Ajustamos la modal-content para permitir scroll 
      si igualmente se hace muy larga. 
      */
      .modal-content {
        max-height: 80vh; 
        overflow-y: auto;
      }
    }

      p {
        font-size: 230%;
        text-align: justify;
        margin: 1rem;
      }
    </style>
  </head>

  <body>
    <!-- CANVAS DE THREE.JS -->
    <canvas class="webgl"></canvas>

    <!-- ENCABEZADO ACTUAL -->
    <h1>
      Con Cari√±o <br />
      <h3>(Toca en el centro)</h3>
    </h1>

    <!-- BOT√ìN EXISTENTE PARA REPRODUCIR M√öSICA -->
    <button
      id="play-music"
      class="boton1"
      type="button"
      aria-label="Play music"
    >
      <svg fill="currentColor" viewBox="0 0 512 512" width="100" title="music">
        <path
          d="M470.38 1.51L150.41 96A32 32 0 0 0 128 126.51v261.41A139 139 0 0 0 96 384c-53 0-96 28.66-96 64s43 64 96 64 96-28.66 96-64V214.32l256-75v184.61a138.4 138.4 0 0 0-32-3.93c-53 0-96 28.66-96 64s43 64 96 64 96-28.65 96-64V32a32 32 0 0 0-41.62-30.49z"
        />
      </svg>
    </button>

    <!-- BOT√ìN PARA ABRIR EL MODAL (PUEDES POSICIONARLO DONDE QUIERAS) -->
    <button
      class="btn btn-primary"
      type="button"
      data-bs-toggle="modal"
      data-bs-target="#uniqueLeftModal"
      style="position: absolute; top: 1rem; right: 1rem; z-index: 999999; width: 260px; height: 90px; font-size: 30px; border-radius: 30px; background-color: red; font-weight: bold;"
    >
      Leeme por favor
    </button>

   <!-- MODAL IZQUIERDO RESPONSIVO -->
<div 
class="modal fade" 
id="uniqueLeftModal" 
tabindex="-1" 
aria-labelledby="uniqueLeftModalLabel" 
aria-hidden="true"
>
<div 
  class="modal-dialog modal-dialog-slideleft" 
  role="document"
>
  <!-- Usamos .modal-content para que su scroll funcione -->
  <div class="modal-content">
    <div class="modal-header">
      <h5 
        class="modal-title w-100 text-center" 
        id="uniqueLeftModalLabel"
      style="color: red; font-weight: bold; font-size: 50px; font-family: Georgia, 'Times New Roman', Times, serif;">
        DESDE LO MAS PROFUNDO DE MI CORAZON
      </h5>
      <button 
        type="button" 
        class="btn-close" 
        data-bs-dismiss="modal" 
        aria-label="Cerrar"
      ></button>
      <hr>
    </div>
    <div class="modal-body">
      <p>üåü ¬°Hola, Lilian! üåü</p>

      <p>Hace semanas que mi coraz√≥n y mente se detienen,  
      debatiendo si este sentir es un sue√±o o un camino que viene.  
      Hoy, con respeto y sinceridad en mi coraz√≥n,  
      me armo de valor para expresarte mi intenci√≥n. ‚ù§Ô∏è</p>
      
      <p>Que me gustas, y aunque a√∫n no nos conozcamos del todo,  
      mi deseo es construir algo bueno, paso a paso y a tu modo.  
      S√© que esto podr√≠a tomarte por sorpresa,  
      pero solo busco ser honesto, sin ninguna certeza. ü§ç</p>
      
      <p>Como el guerrero que teme su pr√≥xima batalla,  
      vengo a confesarte mi cari√±o, que hoy me embarga.  
      No es amor a√∫n, ser√≠a muy temprano decir,  
      pero mi anhelo es conocerte mejor y descubrir. üõ°Ô∏è‚ú®</p>
      
      <p>Con el mayor respeto y mi coraz√≥n sincero,  
      me gustar√≠a invitarte a compartir un momento ligero.  
      Una cena, una charla donde pueda escuchar tu risa,  
      y juntos disfrutar de una noche sencilla, pero precisa. üçΩÔ∏èüòä</p>
      
      <p>No busco m√°s que conocerte en verdad,  
      y que el tiempo nos gu√≠e con serenidad.  
      Si tu coraz√≥n permite que camine a tu lado,  
      prometo que mis pasos ser√°n siempre guiados. üôèüí´</p>
      
      <p>Lilian, aqu√≠ estoy, con palabras honestas,  
      esperando que este gesto sea tomado con nobleza.  
      ¬øMe dar√≠as la oportunidad de aprender de ti,  
      y juntos escribir un cap√≠tulo lleno de paz y alegr√≠a en el porvenir? ‚úçÔ∏èüå∏</p>
      
      <hr>
      <p style="font-size: 25px;"> <b> (Psdt. Toca en el centro del corazon para que veas la animacion del corazon)</b></p>
    </div>
    <div class="modal-footer">
      <button 
        type="button" 
        class="btn btn-secondary" 
        data-bs-dismiss="modal"
      >
        Cerrar
      </button>
    </div>
  </div>
</div>
</div>
    <!-- SHADERS EXISTENTES (vertexShader, fragmentShader, etc.) -->
    <!-- ======================================================= -->
    <script type="x-shader/x-vertex" id="vertexShader">
      /* ... tu c√≥digo existente de vertexShader ... */
      #define M_PI 3.1415926535897932384626433832795
      uniform float uTime;
      uniform float uSize;
      attribute float aScale;
      attribute vec3 aColor;
      attribute float random;
      attribute float random1;
      attribute float aSpeed;
      varying vec3 vColor;
      varying vec2 vUv;

      void main() {
        float sign = 2.0* (step(random, 0.5) -.5);
        float t = sign*mod(-uTime *  aSpeed* 0.005  + 10.0*aSpeed*aSpeed, M_PI);
        float a = pow(t, 2.0) * pow((t - sign * M_PI), 2.0);
        float radius = 0.14;
        vec3 myOffset =
            vec3(t,  1.0, 0.0);
        myOffset = vec3(radius *16.0 * pow(sin(t), 2.0) * sin(t), radius * (13.0 * cos(t) - 5.0 * cos(2.0 * t) - 2.0 * cos(3.0 * t) - cos(4.0 * t)), .15*(a*(random1 - .5))*sin(abs(10.0*(sin(.2*uTime + .2*random)))*t));
        vec3 displacedPosition = myOffset;
        vec4 modelPosition = modelMatrix * vec4(displacedPosition.xyz, 1.0);

        vec4 viewPosition = viewMatrix * modelPosition;
        viewPosition.xyz += position * aScale * uSize * pow(a, .5) * .5;
        gl_Position = projectionMatrix * viewPosition;

        vColor = aColor;
        vUv = uv;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
      /* ... tu c√≥digo existente de fragmentShader ... */
      varying vec3 vColor;
      varying vec2 vUv;

      void main() {
        vec2 uv = vUv;
        vec3 color = vColor;
        float strength = distance(uv, vec2(0.5));
        strength *= 2.0;
        strength = 1.0 - strength;
        gl_FragColor = vec4(strength * color, 1.0);
      }
    </script>

    <script type="x-shader/x-vertex" id="vertexShader1">
      /* ... tu c√≥digo existente de vertexShader1 ... */
      #define M_PI 3.1415926535897932384626433832795
      uniform float uTime;
      uniform float uSize;
      attribute float aScale;
      attribute vec3 aColor;
      attribute float phi;
      attribute float random;
      attribute float random1;
      varying vec3 vColor;
      varying vec2 vUv;

      void main() {
        float t = 0.01 * uTime + 12.0;
        float angle = phi;
        
        t = mod((-uTime + 100.0) * 0.06* random1 + random *2.0 * M_PI , 2.0 * M_PI);
        vec3 myOffset = vec3(5.85*cos(angle * (t )), 2.0*(t - M_PI), 3.0*sin(angle * (t )/t));
        vec4 modelPosition = modelMatrix * vec4(myOffset, 1.0);
        vec4 viewPosition = viewMatrix * modelPosition;
        viewPosition.xyz += position * aScale * uSize;
        gl_Position = projectionMatrix * viewPosition;

        vColor = aColor;
        vUv = uv;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader1">
      /* ... tu c√≥digo existente de fragmentShader1 ... */
      uniform sampler2D uTex;
      varying vec3 vColor;
      varying vec2 vUv;

      void main() {
        vec2 uv = vUv;
        vec3 color = vColor;
        float strength = distance(uv, vec2(0.5, .65));
        strength *= 2.0;
        strength = 1.0 - strength;
        vec3 texture = texture2D(uTex, uv).rgb;
        gl_FragColor = vec4(texture * color * (strength + .3), 1.);
      }
    </script>

    <!-- SCRIPT PRINCIPAL DE THREE.JS (WORLD CLASS) -->
    <script type="module">
      import * as THREE from "https://cdn.skypack.dev/three@0.135.0";
      import { gsap } from "https://cdn.skypack.dev/gsap@3.8.0";
      import { GLTFLoader } from "https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/GLTFLoader.js";

      class World {
        constructor({ canvas, width, height, cameraPosition, fieldOfView = 75, nearPlane = 0.1, farPlane = 100 }) {
          this.parameters = {
            count: 1500,
            max: 12.5 * Math.PI,
            a: 2,
            c: 4.5
          };

          this.textureLoader = new THREE.TextureLoader();
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x16000a);
          this.clock = new THREE.Clock();
          this.data = 0;
          this.time = { current: 0, t0: 0, t1: 0, t: 0, frequency: 0.0005 };
          this.angle = { x: 0, z: 0 };
          this.width = width || window.innerWidth;
          this.height = height || window.innerHeight;
          this.aspectRatio = this.width / this.height;
          this.fieldOfView = fieldOfView;

          this.camera = new THREE.PerspectiveCamera(
            this.fieldOfView,
            this.aspectRatio,
            nearPlane,
            farPlane
          );
          this.camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
          this.scene.add(this.camera);

          this.renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true
          });
          this.pixelRatio = Math.min(window.devicePixelRatio, 2);
          this.renderer.setPixelRatio(this.pixelRatio);
          this.renderer.setSize(this.width, this.height);

          this.timer = 0;
          this.addToScene();
          this.addButton();

          this.render();
          this.listenToResize();
          this.listenToMouseMove();
        }

        start() {}

        render() {
          this.renderer.render(this.scene, this.camera);
          this.composer && this.composer.render();
        }

        loop() {
          this.time.elapsed = this.clock.getElapsedTime();
          this.time.delta = Math.min(60, (this.time.current - this.time.elapsed) * 1000);

          if (this.analyser && this.isRunning) {
            this.time.t = this.time.elapsed - this.time.t0 + this.time.t1;
            this.data = this.analyser.getAverageFrequency();
            this.data *= this.data / 2000;
            this.angle.x += this.time.delta * 0.001 * 0.63;
            this.angle.z += this.time.delta * 0.001 * 0.39;

            const justFinished = this.isRunning && !this.sound.isPlaying;
            if (justFinished) {
              this.time.t1 = this.time.t;
              this.audioBtn.disabled = false;
              this.isRunning = false;
              const tl = gsap.timeline();
              this.angle.x = 0;
              this.angle.z = 0;
              tl.to(this.camera.position, {
                x: 0,
                z: 4.5,
                duration: 4,
                ease: "expo.in"
              });
              tl.to(this.audioBtn, {
                opacity: () => 1,
                duration: 1,
                ease: "power1.out"
              });
            } else {
              this.camera.position.x = Math.sin(this.angle.x) * this.parameters.a;
              this.camera.position.z = Math.min(
                Math.max(Math.cos(this.angle.z) * this.parameters.c, 1.75),
                6.5
              );
            }
          }

          // Mira al centro de la escena
          this.camera.lookAt(this.scene.position);

          // Actualizamos shaders y modelo con la variable 'data'
          if (this.heartMaterial) {
            this.heartMaterial.uniforms.uTime.value +=
              this.time.delta * this.time.frequency * (1 + this.data * 0.2);
          }
          if (this.model) {
            this.model.rotation.y -= 0.0005 * this.time.delta * (1 + this.data);
          }
          if (this.snowMaterial) {
            this.snowMaterial.uniforms.uTime.value +=
              this.time.delta * 0.0004 * (1 + this.data);
          }

          this.render();
          this.time.current = this.time.elapsed;
          requestAnimationFrame(this.loop.bind(this));
        }

        listenToResize() {
          window.addEventListener("resize", () => {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.camera.aspect = this.width / this.height;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(this.width, this.height);
          });
        }

        listenToMouseMove() {
          window.addEventListener("mousemove", (e) => {
            const x = e.clientX;
            const y = e.clientY;
            gsap.to(this.camera.position, {
              x: gsap.utils.mapRange(0, window.innerWidth, 0.2, -0.2, x),
              y: gsap.utils.mapRange(0, window.innerHeight, 0.2, -0.2, -y)
            });
          });
        }

        addHeart() {
          this.heartMaterial = new THREE.ShaderMaterial({
            fragmentShader: document.getElementById("fragmentShader").textContent,
            vertexShader: document.getElementById("vertexShader").textContent,
            uniforms: {
              uTime: { value: 0 },
              uSize: { value: 0.2 },
              uTex: {
                value: new THREE.TextureLoader().load(
                  "https://assets.codepen.io/74321/heart.png"
                )
              }
            },
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            transparent: true
          });

          const count = this.parameters.count;
          const scales = new Float32Array(count);
          const colors = new Float32Array(count * 3);
          const speeds = new Float32Array(count);
          const randoms = new Float32Array(count);
          const randoms1 = new Float32Array(count);
          const colorChoices = ["white", "red", "pink", "crimson", "hotpink", "green"];

          const squareGeometry = new THREE.PlaneGeometry(1, 1);
          this.instancedGeometry = new THREE.InstancedBufferGeometry();

          Object.keys(squareGeometry.attributes).forEach((attr) => {
            this.instancedGeometry.attributes[attr] = squareGeometry.attributes[attr];
          });
          this.instancedGeometry.index = squareGeometry.index;
          this.instancedGeometry.maxInstancedCount = count;

          for (let i = 0; i < count; i++) {
            const i3 = 3 * i;
            randoms[i] = Math.random();
            randoms1[i] = Math.random();
            scales[i] = Math.random() * 0.35;

            const colorIndex = Math.floor(Math.random() * colorChoices.length);
            const color = new THREE.Color(colorChoices[colorIndex]);
            colors[i3 + 0] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;

            speeds[i] = Math.random() * this.parameters.max;
          }

          this.instancedGeometry.setAttribute(
            "random",
            new THREE.InstancedBufferAttribute(randoms, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "random1",
            new THREE.InstancedBufferAttribute(randoms1, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "aScale",
            new THREE.InstancedBufferAttribute(scales, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "aSpeed",
            new THREE.InstancedBufferAttribute(speeds, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "aColor",
            new THREE.InstancedBufferAttribute(colors, 3, false)
          );

          this.heart = new THREE.Mesh(this.instancedGeometry, this.heartMaterial);
          this.scene.add(this.heart);
        }

        async addModel() {
          this.model = await this.loadObj("https://assets.codepen.io/74321/heart.glb");
          this.model.scale.set(0.01, 0.01, 0.01);
          this.model.material = new THREE.MeshMatcapMaterial({
            matcap: this.textureLoader.load(
              "https://assets.codepen.io/74321/3.png",
              () => {
                gsap.to(this.model.scale, {
                  x: 0.35,
                  y: 0.35,
                  z: 0.35,
                  duration: 1.5,
                  ease: "Elastic.easeOut"
                });
              }
            ),
            color: "#ff89aC"
          });
          this.scene.add(this.model);
        }

        addButton() {
          this.audioBtn = document.querySelector("button#play-music");
          this.audioBtn.addEventListener("click", () => {
            this.audioBtn.disabled = true;
            if (this.analyser) {
              this.sound.play();
              this.time.t0 = this.time.elapsed;
              this.data = 0;
              this.isRunning = true;
              gsap.to(this.audioBtn, {
                opacity: 0,
                duration: 1,
                ease: "power1.out"
              });
            } else {
              this.loadMusic().then(() => {
                console.log("music loaded");
              });
            }
          });
        }

        loadObj(path) {
          const loader = new GLTFLoader();
          return new Promise((resolve) => {
            loader.load(
              path,
              (response) => {
                resolve(response.scene.children[0]);
              },
              (xhr) => {},
              (err) => {
                console.log(err);
              }
            );
          });
        }

        loadMusic() {
          return new Promise((resolve) => {
            const listener = new THREE.AudioListener();
            this.camera.add(listener);

            this.sound = new THREE.Audio(listener);
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(
              "https://assets.codepen.io/74321/ukulele.mp3",
              (buffer) => {
                this.sound.setBuffer(buffer);
                this.sound.setLoop(false);
                this.sound.setVolume(0.5);
                this.sound.play();

                this.analyser = new THREE.AudioAnalyser(this.sound, 32);
                const data = this.analyser.getAverageFrequency();
                this.isRunning = true;
                this.t0 = this.time.elapsed;
                resolve(data);
              },
              (progress) => {
                gsap.to(this.audioBtn, {
                  opacity: () => 1 - progress.loaded / progress.total,
                  duration: 1,
                  ease: "power1.out"
                });
              },
              (error) => {
                console.log(error);
              }
            );
          });
        }

        addSnow() {
          this.snowMaterial = new THREE.ShaderMaterial({
            fragmentShader: document.getElementById("fragmentShader1").textContent,
            vertexShader: document.getElementById("vertexShader1").textContent,
            uniforms: {
              uTime: { value: 0 },
              uSize: { value: 0.3 },
              uTex: {
                value: new THREE.TextureLoader().load(
                  "https://assets.codepen.io/74321/heart.png"
                )
              }
            },
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            transparent: true
          });

          const count = 550;
          const scales = new Float32Array(count);
          const colors = new Float32Array(count * 3);
          const phis = new Float32Array(count);
          const randoms = new Float32Array(count);
          const randoms1 = new Float32Array(count);
          const colorChoices = ["red", "pink", "hotpink", "green"];

          const squareGeometry = new THREE.PlaneGeometry(1, 1);
          this.instancedGeometry = new THREE.InstancedBufferGeometry();

          Object.keys(squareGeometry.attributes).forEach((attr) => {
            this.instancedGeometry.attributes[attr] = squareGeometry.attributes[attr];
          });
          this.instancedGeometry.index = squareGeometry.index;
          this.instancedGeometry.maxInstancedCount = count;

          for (let i = 0; i < count; i++) {
            const i3 = 3 * i;
            phis[i] = (Math.random() - 0.5) * 10;
            randoms[i] = Math.random();
            randoms1[i] = Math.random();
            scales[i] = Math.random() * 0.35;

            const colorIndex = Math.floor(Math.random() * colorChoices.length);
            const color = new THREE.Color(colorChoices[colorIndex]);
            colors[i3 + 0] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
          }

          this.instancedGeometry.setAttribute(
            "phi",
            new THREE.InstancedBufferAttribute(phis, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "random",
            new THREE.InstancedBufferAttribute(randoms, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "random1",
            new THREE.InstancedBufferAttribute(randoms1, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "aScale",
            new THREE.InstancedBufferAttribute(scales, 1, false)
          );
          this.instancedGeometry.setAttribute(
            "aColor",
            new THREE.InstancedBufferAttribute(colors, 3, false)
          );

          this.snow = new THREE.Mesh(this.instancedGeometry, this.snowMaterial);
          this.scene.add(this.snow);
        }

        addToScene() {
          this.addModel();
          this.addHeart();
          this.addSnow();
        }
      }

      // Instanciamos nuestra clase World
      const world = new World({
        canvas: document.querySelector("canvas.webgl"),
        cameraPosition: { x: 0, y: 0, z: 4.5 }
      });
      world.loop();
    </script>

    <!-- JS de Bootstrap (con Popper incluido) -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
    ></script>
  </body>
</html>
